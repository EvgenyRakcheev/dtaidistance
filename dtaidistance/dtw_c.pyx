
# coding: utf-8

# In[6]:

get_ipython().magic('load_ext cython')


# In[14]:

get_ipython().run_cell_magic('cython', '', '"""\ndtaidistance.dtw_c - Dynamic Time Warping\n    Part of the DTAI distance code.\n    Copyright 2016 KU Leuven, DTAI Research Group\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n        http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n"""\nimport math\nimport numpy as np\ncimport numpy as np\ncimport cython\nimport cython\nimport ctypes\nfrom cpython cimport array, bool\nfrom cython import parallel\nfrom cython.parallel import parallel, prange\nfrom libc.stdlib cimport abort, malloc, free, abs\nfrom libc.stdio cimport printf\nfrom libc.math cimport sin, cos, acos, exp, sqrt, fabs, M_PI, pow\n\nDTYPE = np.double\nctypedef np.double_t DTYPE_t\ncdef double inf = np.inf\n\n@cython.boundscheck(False) # turn off bounds-checking for entire function\n@cython.wraparound(False)  # turn off negative index wrapping for entire function\ndef distance(np.ndarray[DTYPE_t, ndim=1] s1, np.ndarray[DTYPE_t, ndim=1] s2,\n             int window=0, double max_dist=0,\n             double max_step=0, int max_length_diff=0, double penalty=0):\n    """\n    Dynamic Time Warping (keep compact matrix)\n    :param s1: First sequence (np.array(np.float64))\n    :param s2: Second sequence\n    :param window: Only allow for shifts up to this amount away from the two diagonals\n    :param max_dist: Stop if the returned values will be larger than this value\n    :param max_step: Do not allow steps larger than this value\n    :param max_length_diff: Max length difference between the two sequences\n    :param penalty: Cost incurrend when performing compression or expansion\n    Returns: DTW distance\n    """\n    assert s1.dtype == DTYPE and s2.dtype == DTYPE\n    cdef int r = len(s1)\n    cdef int c = len(s2)\n    if max_length_diff != 0 and abs(r-c) > max_length_diff:\n        return inf\n    if window == 0:\n        window = max(r, c)\n    if max_step == 0:\n        max_step = inf\n    else:\n        max_step *= max_step\n    if max_dist == 0:\n        max_dist = inf\n    else:\n        max_dist *= max_dist\n    penalty *= penalty\n    cdef np.ndarray[DTYPE_t, ndim=2] dtw = np.full((2, min( c +1 ,abs( r -c ) + 2 *( window -1 ) + 1 + 1 +1)), inf)\n    dtw[0, 0] = 0\n    cdef double last_under_max_dist = 0\n    cdef double prev_last_under_max_dist = inf\n    cdef int skip = 0\n    cdef int skipp = 0\n    cdef int i0 = 1\n    cdef int i1 = 0\n    cdef DTYPE_t d\n    for i in range(r):\n        if last_under_max_dist == -1:\n            prev_last_under_max_dist = inf\n        else:\n            prev_last_under_max_dist = last_under_max_dist\n        last_under_max_dist = -1\n        skipp = skip\n        skip = max(0, i - window + 1)\n        i0 = 1 - i0\n        i1 = 1 - i1\n        dtw[i1 ,:] = inf\n        if dtw.shape[1] == c+ 1:\n            skip = 0\n        for j in range(max(0, i - max(0, r - c) - window + 1), min(c, i + max(0, c - r) + window)):\n            d = (s1[i] - s2[j])**2\n            if d > max_step:\n                continue\n            dtw[i1, j + 1 - skip] = d + min(dtw[i0, j - skipp],\n                                            dtw[i0, j + 1 - skipp] + penalty,\n                                            dtw[i1, j - skip] + penalty)\n            if dtw[i1, j + 1 - skip] <= max_dist:\n                last_under_max_dist = j\n            else:\n                dtw[i1, j + 1 - skip] = inf\n                if prev_last_under_max_dist + 1 - skipp < j + 1 - skip:\n                    break\n        if last_under_max_dist == -1:\n            # print(\'early stop\')\n            # print(dtw)\n            return inf\n    # print(dtw)\n    return math.sqrt(dtw[i1, min(c, c + window - 1) - skip])\n\n\ndef distance_nogil(double[:] s1, double[:] s2,\n             int window=0, double max_dist=0,\n             double max_step=0, int max_length_diff=0, double penalty=0):\n    """DTW distance.\n    See distance(). This calls a pure c dtw computation that avoids the GIL.\n    :param s1: First sequence (buffer of doubles)\n    :param s2: Second sequence (buffer of doubles)\n    """\n    #return distance_nogil_c(s1, s2, len(s1), len(s2),\n    # If the arrays (memoryviews) are not C contiguous, the pointer will not point to the correct array\n    if isinstance(s1, (np.ndarray, np.generic)):\n        if not s1.base.flags.c_contiguous:\n            s1 = s1.copy()\n    if isinstance(s2, (np.ndarray, np.generic)):\n        if not s2.base.flags.c_contiguous:\n            s2 = s2.copy()\n    return distance_nogil_c(&s1[0], &s2[0], len(s1), len(s2),\n                            window, max_dist, max_step, max_length_diff, penalty)\n\n\n@cython.boundscheck(False) # turn off bounds-checking for entire function\n@cython.wraparound(False)  # turn off negative index wrapping for entire function\n@cython.infer_types(False)\ncdef double distance_nogil_c(\n             double *s1, double *s2,\n             int r, # len_s1\n             int c, # len_s2\n             int window=0, double max_dist=0,\n             double max_step=0, int max_length_diff=0, double penalty=0) nogil:\n    """DTW distance.\n    See distance(). This is a pure c dtw computation that avoid the GIL.\n    """\n    #printf("%i, %i\\n", r, c)\n    if max_length_diff != 0 and abs(r-c) > max_length_diff:\n        return inf\n    if window == 0:\n        window = max(r, c)\n    if max_step == 0:\n        max_step = inf\n    else:\n        max_step = pow(max_step, 2)\n    if max_dist == 0:\n        max_dist = inf\n    else:\n        max_dist = pow(max_dist, 2)\n    penalty = pow(penalty, 2)\n    cdef int length = min(c+1,abs(r-c) + 2*(window-1) + 1 + 1 + 1)\n    cdef double ** dtw\n    dtw = <double **> malloc(sizeof(double *) * (r + 1))\n    cdef int i\n    for i in range(r + 1):\n        dtw[i] = <double *> malloc(sizeof(double) * (c + 1))\n    cdef int j\n    for i in range(r + 1):\n        for j in range(c + 1):\n            dtw[i][j] = inf\n    dtw[0][0] = 0\n    cdef double last_under_max_dist = 0\n    cdef double prev_last_under_max_dist = inf\n    cdef int i0 = 1\n    cdef int i1 = 0\n    cdef int minj\n    cdef int maxj\n    cdef double minv\n    cdef DTYPE_t d\n    cdef double tempv\n    for i in range(r):\n        if last_under_max_dist == -1:\n            prev_last_under_max_dist = inf\n        else:\n            prev_last_under_max_dist = last_under_max_dist\n        last_under_max_dist = -1\n        maxj = r - c\n        if maxj < 0:\n            maxj = 0\n        maxj = i - maxj - window + 1\n        if maxj < 0:\n            maxj = 0\n        i0 = i\n        i1 = i + 1\n        minj = c - r\n        if minj < 0:\n            minj = 0\n        minj = i + minj + window\n        if minj > c:\n            minj = c\n        for j in range(maxj, minj):\n            d = pow(s1[i] - s2[j], 2)\n            if d > max_step:\n                continue\n            minv = dtw[i0][j]\n            tempv = dtw[i0][j + 1] + penalty\n            if tempv < minv:\n                minv = tempv\n            tempv = dtw[i1][j] + penalty\n            if tempv < minv:\n                minv = tempv\n            dtw[i1][j + 1] = d + minv\n            if dtw[i1][j + 1] <= max_dist:\n                last_under_max_dist = j\n            else:\n                dtw[i1][j + 1] = inf\n                if prev_last_under_max_dist < j + 1:\n                    break\n        if last_under_max_dist == -1:\n            # print(\'early stop\')\n            # print(dtw)\n            return inf\n    cdef int ** path\n    path = <int **> malloc(sizeof(int *) * (r + c - 1))\n    for i in range(r + c - 1):\n        path[i] = <int *> malloc(sizeof(int) * 2)\n        for j in range(2):\n            path[i][j] = 0\n    cdef int cur_i\n    cdef int cur_j\n    cdef int s1_len_cur\n    cdef int s2_len_cur\n    cur_i = r\n    cur_j = c\n    cdef double cur_cell = dtw[cur_i][cur_j]\n    path[0] = [cur_i - 1, cur_j - 1]\n    cdef int ind_of_path = 1\n    while cur_i > 1 or cur_j > 1:\n        s1_len_cur = cur_i\n        s2_len_cur = cur_j\n        if cur_i >= 1 and cur_j >= 1 and dtw[cur_i - 1][cur_j - 1] <= cur_cell:\n            s1_len_cur = cur_i - 1\n            s2_len_cur = cur_j - 1\n            cur_cell = dtw[cur_i - 1][cur_j - 1]\n            \n        if cur_i >= 1 and dtw[cur_i - 1][cur_j] <= cur_cell:\n            s1_len_cur = cur_i - 1\n            s2_len_cur = cur_j\n            cur_cell = dtw[cur_i - 1][cur_j]\n            \n        if cur_j >= 1 and dtw[cur_i][cur_j - 1] <= cur_cell:\n            s1_len_cur = cur_i\n            s2_len_cur = cur_j - 1\n            cur_cell = dtw[cur_i][cur_j - 1]\n            \n        path[ind_of_path] = [s1_len_cur - 1, s2_len_cur - 1]\n        ind_of_path += 1\n        cur_i = s1_len_cur\n        cur_j = s2_len_cur\n    cdef int ** reversed_path\n    reversed_path = <int **> malloc(sizeof(int *) * ind_of_path)\n    for i in range(ind_of_path):\n        reversed_path[i] = <int *> malloc(sizeof(int) * 2)\n        reversed_path[i] = path[ind_of_path - i - 1]\n    cdef int* path_begin = [0, 0]\n    cdef int** path_end\n    path_end = <int **> malloc(sizeof(int *) * (r + c - 1))\n    for i in range(r + c - 1):\n        path_end[i] = <int *> malloc(sizeof(int) * 2)\n        for j in range(2):\n            path_end[i][j] = 0\n    cdef int ind_of_path_end = 0\n    for i in range(ind_of_path):\n        if reversed_path[i][0] == 0 or reversed_path[i][1] == 0:\n            path_begin = reversed_path[i]\n        if reversed_path[i][0] == r - 1 or reversed_path[i][1] == c - 1:\n            path_end[ind_of_path_end] = reversed_path[i]\n            ind_of_path_end += 1\n    cdef double result = dtw[r][c] - dtw[path_begin[0] + 1][path_begin[1] + 1] + \\\n                         (s1[path_begin[0]]-s2[path_begin[1]])**2\n    if ind_of_path_end > 1:\n        for i in range(1, ind_of_path_end):\n            result -= (s1[path_end[i][0]]-s2[path_end[i][1]])**2\n    for i in range(r + 1):\n        free(dtw[i])\n    free(dtw)\n    for i in range(r + c - 1):\n        free(path[i])\n        free(path_end[i])\n    free(path)\n    free(path_end)\n    for i in range(ind_of_path):\n        free(reversed_path[i])\n    free(reversed_path)\n    free(path_begin)\n    return sqrt(result)\n\n\n@cython.boundscheck(False) # turn off bounds-checking for entire function\n@cython.wraparound(False)  # turn off negative index wrapping for entire function\ndef distance_matrix(cur, double max_dist=inf, int max_length_diff=0,\n                    int window=0, double max_step=0, double penalty=0, **kwargs):\n    """Compute a distance matrix between all sequences given in `cur`.\n    """\n    if max_length_diff == 0:\n        max_length_diff = 999999\n    cdef double large_value = inf\n    cdef np.ndarray[DTYPE_t, ndim=2] dists = np.zeros((len(cur), len(cur))) + large_value\n    for r in range(len(cur)):\n        for c in range(r + 1, len(cur)):\n            if abs(len(cur[r]) - len(cur[c])) <= max_length_diff:\n                dists[r, c] = distance(cur[r], cur[c], window=window,\n                                       max_dist=max_dist, max_step=max_step,\n                                       max_length_diff=max_length_diff,\n                                       penalty=penalty)\n    return dists\n\n\ndef distance_matrix_nogil(cur, double max_dist=inf, int max_length_diff=0,\n                          int window=0, double max_step=0, double penalty=0, bool is_parallel=False, **kwargs):\n    """Compute a distance matrix between all sequences given in `cur`.\n    This method calls a pure c implementation of the dtw computation that\n    avoids the GIL.\n    """\n    # https://github.com/cython/cython/wiki/tutorials-NumpyPointerToC\n    # Prepare for only c datastructures\n    if max_length_diff == 0:\n        max_length_diff = 999999\n    cdef double large_value = inf\n    dists_py = np.zeros((len(cur), len(cur))) + large_value\n    cdef np.ndarray[DTYPE_t, ndim=2, mode="c"] dists = dists_py\n    #print(\'dists: {}, {}\'.format(dists_py.shape, dists_py.shape[0]*dists_py.shape[1]))\n    cdef double **cur2 = <double **> malloc(len(cur) * sizeof(double*))\n    cdef int *cur2_len = <int *> malloc(len(cur) * sizeof(int))\n    cdef long ptr;\n    cdef np.ndarray[DTYPE_t, ndim=2, mode="c"] cur_np;\n    #for i in range(len(cur)):\n    #    print(cur[i])\n    if type(cur) in [list, set]:\n        for i in range(len(cur)):\n            ptr = cur[i].ctypes.data\n            cur2[i] = <double *> ptr\n            cur2_len[i] = len(cur[i])\n    elif isinstance(cur, np.ndarray):\n        if not cur.flags.c_contiguous:\n            cur = cur.copy(order=\'C\')\n        cur_np = cur\n        for i in range(len(cur)):\n            cur2[i] = &cur_np[i,0]\n            cur2_len[i] = cur_np.shape[1]\n    else:\n        return None\n    if is_parallel:\n        distance_matrix_nogil_c_p(cur2, len(cur), cur2_len, &dists[0,0], max_dist, max_length_diff, window, max_step, penalty)\n    else:\n        distance_matrix_nogil_c(cur2, len(cur), cur2_len, &dists[0,0], max_dist, max_length_diff, window, max_step, penalty)\n    free(cur2)\n    free(cur2_len)\n    return dists_py\n\n\ndef distance_matrix_nogil_p(cur, double max_dist=inf, int max_length_diff=0,\n                          int window=0, double max_step=0, double penalty=0, **kwargs):\n    """Compute a distance matrix between all sequences given in `cur`.\n    This method calls a pure c implementation of the dtw computation that\n    avoids the GIL and executes them in parallel.\n    """\n    return distance_matrix_nogil(cur, max_dist=max_dist, max_length_diff=max_length_diff,\n                                 window=window, max_step=max_step, penalty=penalty,\n                                 is_parallel=True, **kwargs)\n\n\ncdef distance_matrix_nogil_c(double **cur, int len_cur, int* cur_len, double* output,\n                             double max_dist=0, int max_length_diff=0,\n                             int window=0, double max_step=0, double penalty=0):\n    #for i in range(len_cur):\n    #    print(i)\n    #    print(cur_len[i])\n    #    for j in range(cur_len[i]):\n    #        printf("%f ", cur[i][j])\n    #    printf("\\n")\n    #printf("---\\n")\n    cdef int r\n    cdef int c\n    for r in range(len_cur):\n        for c in range(r + 1, len_cur):\n            output[len_cur*r + c] = distance_nogil_c(cur[r], cur[c], cur_len[r], cur_len[c],\n                                                     window=window, max_dist=max_dist,\n                                                     max_step=max_step, max_length_diff=max_length_diff,\n                                                     penalty=penalty)\n            #for i in range(len_cur):\n            #    for j in range(len_cur):\n            #        printf("%f ", output[i*len_cur+j])\n            #    printf("\\n")\n            #printf("---\\n")\n\n\ncdef distance_matrix_nogil_c_p(double **cur, int len_cur, int* cur_len, double* output,\n                             double max_dist=0, int max_length_diff=0,\n                             int window=0, double max_step=0, double penalty=0):\n    # Requires openmp which is not supported for clang on mac\n    cdef Py_ssize_t r\n    cdef Py_ssize_t c\n\n    with nogil, parallel():\n        for r in prange(len_cur):\n            for c in range(r + 1, len_cur):\n                output[len_cur*r + c] = distance_nogil_c(cur[r], cur[c], cur_len[r], cur_len[c],\n                                                         window=window, max_dist=max_dist,\n                                                         max_step=max_step, max_length_diff=max_length_diff,\n                                                         penalty=penalty)')

